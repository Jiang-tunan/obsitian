# 一 基本概念
## 1 进程(Process)
### 定义
	 是并发执行的程序在执行过程中分配和管理资源的基本单位.是一个动态概念,竞争计算机资源的基本单位.
	 1.并发执行?
		 并发执行是指在同一时间段内,多个任务和进程可以交替执行,共享计算机资源的情况,虽然任意时刻只有一个任务在执行,但是由于切换速度非常快,所以感觉是在同时执行.
		 优点:
		 提高系统系统性能,增强响应能力 资源共享 任务分离
### 特点
	1. 每个进程都有自己独立的地址空间,相互之间不会干扰,一个进程崩溃不会影响其他进程.
	2. 进程拥有独立的资源,如文件描述符,内存等.不同进程之间资源不能直接共享.
	3. 进程切换开销较大,需要切换进程空间和状态.
## 2 线程(Thread)
### 定义
	线程是进程内独立执行的一个流程,共享进程的地址空间和资源.
### 特点
	1. 线程可以共享同一进程内资源,线程间通信相对简单.
	2. 线程切换开销较小,只需要切换执行流程和少量状态.
## 3.协程(Coroutine)
### 定义
	协程是计算机程序组件,类似于线程,但是不被计算机内核所管理.是由程序员自行控制的一种并发执行单位,可以在程序中多次挂起和恢复,允许在不同的执行点之间切换.
### 特点
	1. 非抢占式调度:协程不像线程那样由操作系统进行抢占式调度,而是由程序员在程序中显示的控制协程的挂起和恢复,减少上下文切换的开销.
	2. 协作式多任务:协程采用协作式调度,一个协程执行时可以主动让出控制权,使其它协程得以执行.这种方式更适合于需要协同工作的任务,例如事件循环,异步编程等.
	3. 共享数据:协程之间可以共享数据,不需要像线程通信那样通过锁来同步访问资源,可以避免并发问题,减少死锁和竞态条件的风险.
	4. 轻量级:由于不需要操作系统的内核支持,协程的创建和销毁开销较小,可以创建大量协程.

# 二 通信
## 1 管道
### 匿名管道(Anonymous Pipe)
	最常见的管道形式,用于在父子进程之间或同一进程内两个线程之间传递数据,匿名管道是单向的,只能在一个方向上传输数据.
### 命名管道(FIFO)
	允许不相干的进程通过文件路径进行通信,用于不同进程简单通信.
### 特点
	1. 单向通信:匿名管道是单向的,只能从一个方向传递数据,数据只能从管道的写入端流向读取端.
	2. 有限容量:匿名管道有一个有限的缓存区,一旦缓存区满了,写入端就会被阻塞,直到有足够的空间.
	3. 父子关系: 匿名管道通常在父子进程之间创建,这是因为它们共享相同的文件描述符.
	4. 半双工:匿名管道是半双工通信,数据只能从一个方向传输,需要创建两个管道来实现双向通信.
### 使用步骤
	1. 创建管道: 使用系统调用'pipe()'来创建管道.会返回两个文件描述符,一个用于读取,一个用于写入.
	2. fork子进程: 通常在父进程中调用'fork()'来创建子进程,子进程会继承父进程的文件描述符.
	3. 关闭不需要的文件描述符:父进程通常关闭读取端,而子进程关闭写入端,以确保每个进程只是用一个方向的管道.
	4. 通过文件描述符进行读写: 父进程使用写入端写入数据,子进程使用读取端读取数据.
### 示例
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    int fd[2]; // 文件描述符数组，0为读取端，1为写入端
    char buffer[20];
    pipe(fd); // 创建管道

    if (fork() == 0) { // 子进程
        close(fd[1]); // 关闭写入端
        read(fd[0], buffer, sizeof(buffer));
        printf("Child received: %s\n", buffer);
        close(fd[0]); // 关闭读取端
    } else { // 父进程
        close(fd[0]); // 关闭读取端
        write(fd[1], "Hello, pipe!", 12);
        close(fd[1]); // 关闭写入端
    }

    return 0;
}

```

## 2 消息队列
	消息队列是一种进程间通信（IPC）机制，用于在不同进程之间传递数据、消息或者事件。它是一种异步通信方式，允许一个进程将消息放入队列，另一个进程从队列中取出消息并处理。以下是消息队列的详细介绍：
### 类型
- **POSIX 消息队列**: 支持在 Linux 上使用,提供了多种特性,如消息**优先级, 阻塞和非阻塞**操作等.
- **System V消息队列**: 是 UNIX 系统中的一种消息队列, 使用 IPC 键标识队列, 支持消息优先级.
### 特点
1. **异步通信**:发送消息进程不需要等待接收者立即处理消息,从而实现异步通信每提高系统并发性和效率.
2. **解耦合**: 消息队列可以解耦合不同进程之间的依赖关系,因为发送方和接收方不需要直接咋hi到对方的存在.
3. **持久化**: 一些消息队列可以持久化消息,确保消息即使在发送或接收进程关闭后也不会丢失.
4. **多对多**: 多个进程可以同时发送和接收信息,实现多对多的通信模式.
### 使用步骤及示例
[[消息队列 | 消息队列实现]]
## 信号量(Semaphore)
信号量是一种用于多进程和多线程并发控制的同步机制, 用于管理对共享资源的访问. 它主要用于解决多个进程/线程之间的互斥访问和同步执行的问题. 信号量提供了一种计数器的概念, 可与控制同时访问共享资源的数量.
### 基本概念
- 信号量是一个计数器, 用于记录可以同时访问共享资源的进程/线程数量.
- 信号量的值可以被多个进程/线程同时访问和修改, 因此需要通过原子操作来保证原子性.
### 操作
- 初始化: 信号量需要在使用之前进行初始化, 通常设置为资源的初始数量. 初始化后, 信号量的值可以通过两种操作来增加和减少.
- 增加操作(Release): 当一个进程/线程使用完共享资源后, 会释放信号量, 使其值加 1 , 表示释放了一个资源.
- 减少操作(Wait/Dowm/P): 在进程/线程需要访问共享资源之前, 它会执行减少操作, 将信号量减少 1 , 如果信号量的值变为负数, 表示资源被占用, 该进程/线程需要等待.
### 类型
- 二进制信号量(Binary Semaphore): 也称互斥锁(Mutex), 只能取两个值, 0 and 1, 用于实现互斥访问, 保证只有一个进程/线程可以访问共享资源.
- 计数量信号(Coutning Semaphore): 可以去多个正整数值, 用于控制共享资源的数量, 例如线程池中的线程数量.
### 应用场景
- 互斥访问: 通过二进制信号量实现对共享资源的互斥访问, 避免多个进程/线程同时修改数据造成的问题.
- 同步执行: 通过信号量实现进程/线程的同步执行, 确保他们按照特定的顺序执行.
- 资源管理: 计数信号量可用于控制共享资源的数量, 例如线程池,中线程的数量.
- 解决死锁: 通过设置合适的信号量值可以操作顺序, 可以避免产生死锁的情况.
### 信号量和互斥锁的区别
- 信号量可以管理多个资源, 而互斥锁只可以管理一个资源.
- 互斥锁只有两种状态(锁定和未锁定), 而信号量有多个状态.
- 信号量操作包括增加和减少, 而互斥锁只有锁定和解锁操作.

## 共享内存区
共享内存是一种用于多进程/多线程通信就机制, 它允许不同进程/线程共享同一块内存区域, 从而实现高效的数据交换和共享. 相比于其它通信方式, 共享内存的访问速度更快, 但需要开发者自行管理同步和互斥问题. 
- 共享内存是一块由操作系统分配的内存区域, 用于多进程/多线程之间共享数据. 
### 操作
- 创建和映射: 首先, 需要通过操作系统的API创建共享内存区域, 并把它映射到进程/线程的地址空间中.
- 读写操作: 进程/线程可以通过指针直接在共享内存区域进行读写操作, 无需数据的复制.
- 同步和互斥: 由于多个进程/线程可以同时访问共享内存, 需要开发者自行管理同步和互斥, 以避免竞态条件和数据不一致.
### 优点
- 高效性: 共享内存的数据读写速度比其他通信方式都快, 适用于大量数据交换,的情况. 
- 简单性; 相对于消息传递等通信方式, 共享内存的接口和操作较为简单.
### 缺点
- 同步问题: 需要开发者自行管理并发访问的同步和互斥问题. 比卖你静态条件和数据不一致.
- 复杂性: 因为需要同步处理问题, 所以相对其他通信方式, 开发和维护的复杂性较高.
- 安全性: 共享内存的数据访问不受限制,. 因此需要确保数据的安全性和一致性.
### 应用场景
- 多进程/线程通信: 
- 并行计算:
- 数据共享:
